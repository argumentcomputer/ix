import Ix.Common
import Ix.Address

namespace Ix

/-
Ix.IR is an internal representation of the Lean kernel values defined in
[Lean.Declaration](https://leanprover-community.github.io/mathlib4_docs/Lean/Declaration.html)
The purpose of Ix.IR is to separate-in-place alpha-invariant or nameless
computational information from non-computational symbolic or ergonomic metadata.

Ix.IR is generated as an intermediate output from the Ix compiler in Ix.CompileM,
in the course of generating the anonymously content-addressed Ixon bytecode.
Ix.IR is consumed by the Ix transporter in Ix.TransportM, which completes
separation or "dematerialization" of the Lean kernel into Ixon bytecode and Ixon
metadata. The transporter can also reconstitute, or "rematerialize" Ix IR from
the Ixon wire-format.

Finally, Ix.IR can be converted back into Lean kernel values via Ix.DecompileM

The Ix IR differs from the Lean kernel in the following ways:

1. It excludes all `unsafe` constants, as these are not guaranteed to be
   well-defined in the pure setting of a zero-knowledge prover
2. It excludes free variables and metavariables in expressions, all Ix IR terms
are closed.
3. It guarantees disambiguation of all names with de-bruijn index (int the case
   of universe variables) and hash Addresses in the case of global constant
   references. These Addresses are generated by hashing the anonymous Ixon
   bytecode of the referenced constant, following dematerialization. The
   separated metadata is also hashed and stored in-place in the Expr.const
   reference.
4. Since inductive datatypes are content-addressed namelessly, only the type of
   an inductive and the type and order of its constructors are relevant for
   defining an Ix inductive. Consequently, the datatypes

   ```lean
   inductive Boolean where
   | false : Bool
   | true : Bool

   inductive Loobean where
   | true : Bool
   | false : Bool
   ```

   compile to identical Ixon inductives, with the same Ix address (differing
   only in their metadata)

   As a consequence, Ix will accept as valid the following Lean code:

   ```lean
   def Boolean.and (x y: Boolean) : Boolean
   | .true, .true => true
   | _, _ => false

   def coerceLoobeanAsBoolean : Bool := Boolean.and Loobean.false Loobean.false
   ```

   We conjecture that this does not cause soundness issues in the Ix
   typechecker, as one can treat this case as the Ix compiler inferring an
   implicit coercion between isomorphic datatypes like so:

   ```
   def Loobean.toBoolean : Loobean -> Boolean
   | .true => Boolean.false
   | .false => Boolean.true

   def coerceLoobeanAsBoolean : Bool :=
    Boolean.and Loobean.false.toBoolean Loobean.false.toBoolean
   ```

   However, we have not rigorously demonstrated this yet, and therefore best
   practice is to only pass environments to Ix which have passed Lean
   typechecking to sanitize this case.
-/

/--
Ix.Level universe levels are almost identical to Lean.Level, except that they
exclude metavariables and de-bruijn index variable parameters.
--/
inductive Level
  | zero
  | succ : Level → Level
  | max  : Level → Level → Level
  | imax : Level → Level → Level
  | param: Lean.Name → Nat → Level
  deriving Inhabited, Ord, BEq, Hashable, Repr

/--
Ix.Expr expressions are similar to Lean.Expr, except they exclude free variables
and metavariables, and annotate global constant references with Ix.Address
content-addresses
--/
inductive Expr
  | var   (idx: Nat)
  | sort  (univ: Level)
  | const (name: Lean.Name) (ref: Address) (meta: Address) (univs: List Level)
  | rec_  (name: Lean.Name) (idx: Nat) (univs: List Level)
  | app   (func: Expr) (argm: Expr)
  | lam   (name: Lean.Name) (info: Lean.BinderInfo) (type: Expr) (body: Expr)
  | pi    (name: Lean.Name) (info: Lean.BinderInfo) (type: Expr) (body: Expr)
  | letE  (name: Lean.Name) (type: Expr) (value: Expr) (body: Expr) (nonDep: Bool)
  | lit   (lit: Lean.Literal)
  | proj  (typeName: Lean.Name) (typeCont: Address) (typeMeta: Address) (idx: Nat) (struct: Expr)
  deriving Inhabited, Ord, BEq, Repr, Hashable


/--
Ix.Quotient quotients are analogous to Lean.QuotVal
--/
structure Quotient where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Expr
  kind : Lean.QuotKind
  deriving Ord, BEq, Hashable, Repr, Nonempty

/--
Ix.Axiom axioms are analogous to Lean.AxiomVal, differing only in not including
the `isUnsafe` parameter, as Ix constants are never unsafe
--/
structure Axiom where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Expr
  isUnsafe: Bool
  deriving Ord, BEq, Hashable, Repr, Nonempty

structure PreDefinition where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Lean.Expr
  mode : DefKind
  value : Lean.Expr
  hints : Lean.ReducibilityHints
  safety : Lean.DefinitionSafety
  all : List Lean.Name
  deriving BEq, Repr, Nonempty

def mkPreDefinition (x: Lean.DefinitionVal) : PreDefinition := 
  ⟨x.name, x.levelParams, x.type, .definition, x.value, x.hints, x.safety, x.all⟩

def mkPreTheorem (x: Lean.TheoremVal) : PreDefinition := 
  ⟨x.name, x.levelParams, x.type, .theorem, x.value, .opaque, .safe, x.all⟩

def mkPreOpaque (x: Lean.OpaqueVal) : PreDefinition := 
  ⟨x.name, x.levelParams, x.type, .opaque, x.value, .opaque,
    if x.isUnsafe then .unsafe else .safe, x.all⟩

/--
Ix.Definition definitions combine Lean.DefinitionVal, Lean.OpaqueVal and
Lean.TheoremVal into a single structure in order to enable content-addressing of
mutually recursive blocks. These cases are disambiguated via the Ix.DefKind
inductive. ReducibilityHints are preserved only as metadata, and are set to
`ReducibilityHints.opaque` and ignored if the DefKind is either .opaque or
.theorem. The `safety : Lean.DefinitionSafety` parameter from DefinitionVal is
replaced with a boolean for partial definitions, as Ix definitions are
restricted to exclude unsafe constants.
--/
structure Definition where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Expr
  mode: DefKind
  value : Expr
  hints : Lean.ReducibilityHints
  safety: Lean.DefinitionSafety
  all : List Lean.Name
  deriving BEq, Ord, Hashable, Repr, Nonempty

def mkTheorem
  (name: Lean.Name)
  (levelParams: List Lean.Name)
  (type: Expr)
  (value: Expr)
  (all: List Lean.Name)
  : Definition
  := ⟨name, levelParams, type, .theorem, value, .opaque, .safe, all⟩

def mkOpaque
  (name: Lean.Name)
  (levelParams: List Lean.Name)
  (type: Expr)
  (value: Expr)
  (all: List Lean.Name)
  (isUnsafe: Bool)
  : Definition
  := ⟨name, levelParams, type, .opaque, value, .opaque, if isUnsafe then .unsafe else .safe, all⟩

/--
Ix.Constructor inductive datatype constructors are analogous to
Lean.ConstructorVal. The primary difference is that Ix.Constructor only appears
within an Ix.Inductive, and is not directly present in the top level
environment. This is done to enable content-addressing of inductive datatypes.
Instead, Ix.ConstructorProj is used to project or access an inductive
constructor at the top level. Unlike other Ix constants, the `name` parameter is
represented here, but only as metadata to aid in decompilation.
--/
structure Constructor where
  name : Lean.Name
  levelParams : List Lean.Name
  type : Expr
  cidx : Nat
  numParams : Nat
  numFields : Nat
  isUnsafe: Bool
  deriving BEq, Ord, Hashable, Repr, Nonempty

/--
Ix.RecursorRule is analogous to Lean.RecursorRule 
--/
structure RecursorRule where
  ctor : Lean.Name
  nfields : Nat
  rhs : Expr
  deriving BEq, Ord, Hashable, Repr, Nonempty

/--
Ix.Recursor represents inductive recursors and is analogous to Lean.RecursorVal.
However, like Ix.Constructor, recursors do not appear directly in the top-level
environment but are instead held directly within their corresponding Inductive.
Recursors are accessed in an environment using the `Ix.RecursorProj` projection
constant
--/
structure Recursor where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Expr
  numParams : Nat
  numIndices : Nat
  numMotives : Nat
  numMinors  : Nat
  rules : List RecursorRule
  k : Bool
  isUnsafe: Bool
  deriving BEq, Ord, Hashable, Repr, Nonempty

/--
Ix.PreInductive is used to capture a Lean.InductiveVal along with their
constructors and recursors, in order to perform structural sorting
--/
structure PreInductive where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Lean.Expr
  numParams : Nat
  numIndices : Nat
  all : List Lean.Name
  ctors : List Lean.ConstructorVal
  recrs : List Lean.RecursorVal
  numNested: Nat
  isRec : Bool
  isReflexive : Bool
  isUnsafe: Bool
  deriving BEq, Repr, Nonempty

/--
Ix.Inductive represents inductive datatypes and is analogous to
Lean.InductiveVal. However, unlike in Lean, Ix.Inductive directly contains its
corresponding Constructors and Recursors in order to enable content-addressing.
--/
structure Inductive where
  name: Lean.Name
  levelParams : List Lean.Name
  type : Expr
  numParams : Nat
  numIndices : Nat
  all : List Lean.Name
  ctors : List Constructor
  recrs : List Recursor
  numNested: Nat
  isRec : Bool
  isReflexive : Bool
  isUnsafe: Bool
  deriving BEq, Ord, Hashable, Repr, Nonempty


structure InductiveProj where
  /-- name of an inductive within a mutual inductive block --/
  name: Lean.Name
  /-- content-address of a mutual inductive block --/
  blockCont : Address
  /-- metadata content-address a mutual inductive block --/
  blockMeta : Address
  /-- index of the specific inductive datatype within the block --/
  idx   : Nat
  deriving BEq, Ord, Hashable, Repr, Nonempty

structure ConstructorProj where
  /-- name of a specific constructor within an inductive --/
  name: Lean.Name
  /-- content-address of a mutual inductive block --/
  blockCont : Address
  /-- metadata content-address a mutual inductive block --/
  blockMeta : Address
  /-- index of a specific inductive datatype within the block --/
  idx   : Nat
  /-- name of a specific inductive datatype within the block --/
  induct: Lean.Name
  /-- index of a specific constructor within the inductive --/
  cidx  : Nat
  deriving BEq, Ord, Hashable, Repr, Nonempty

structure RecursorProj where
  /-- name of a specific recursor within the inductive --/
  name: Lean.Name
  /-- content-address of a mutual inductive block --/
  blockCont : Address
  /-- metadata content-address of a mutual inductive block --/
  blockMeta : Address
  /-- index of a specific inductive datatype within the block --/
  idx : Nat
  /-- name of a specific inductive datatype within the block --/
  induct: Lean.Name
  /-- index of a specific recursor within the inductive --/
  ridx : Nat
  deriving BEq, Ord, Hashable, Repr, Nonempty

structure DefinitionProj where
  name: Lean.Name
  /-- content-address of a mutual definition block --/
  blockCont : Address
  /-- metadata content-address of a mutual definition block --/
  blockMeta : Address
  /-- index of a specific definition within the block --/
  idx : Nat
  deriving BEq, Ord, Hashable, Repr, Nonempty

structure MutualBlock where
  defs : List (List Definition)
  --all: List Lean.Name
  deriving BEq, Ord, Hashable, Repr, Nonempty

def MutualBlock.ctx (x: MutualBlock) : List (List Lean.Name) :=
  x.defs.map fun xs => xs.map fun x => x.name

structure InductiveBlock where
  inds : List (List Inductive)
  --all: List Lean.Name
  deriving BEq, Ord, Hashable, Repr, Nonempty, Inhabited

def InductiveBlock.ctx (x: InductiveBlock) : List (List Lean.Name) :=
  x.inds.map fun xs => xs.map fun x => x.name

inductive Const where
  | «axiom» : Axiom → Const
  | quotient : Quotient → Const
  | «definition»: Definition → Const
  -- projections of mutual blocks
  | inductiveProj : InductiveProj → Const
  | constructorProj : ConstructorProj → Const
  | recursorProj : RecursorProj → Const
  | definitionProj : DefinitionProj → Const
  -- constants to represent mutual blocks
  | «mutual» : MutualBlock → Const
  | «inductive» : InductiveBlock → Const
  deriving Ord, BEq, Inhabited, Repr, Nonempty

def Const.isMutBlock : Const → Bool
  | .mutual _ | .inductive _ => true
  | _ => false

namespace Level

/--
Reduces as a `max` applied to two values: `max a 0 = max 0 a = a` and
`max (succ a) (succ b) = succ (max a b)`.
It is assumed that `a` and `b` are already reduced
-/
def reduceMax (a b : Level) : Level :=
  match a, b with
  | .zero, _ => b
  | _, .zero => a
  | .succ a, .succ b => .succ (reduceMax a b)
  | .param _ idx, .param _ idx' => if idx == idx' then a else .max a b
  | _, _ => .max a b

/--
Reduces as an `imax` applied to two values.
It is assumed that `a` and `b` are already reduced
-/
def reduceIMax (a b : Level) : Level :=
  match b with
  -- IMax(a, b) will reduce to 0 if b == 0
  | .zero => .zero
  -- IMax(a, b) will reduce as Max(a, b) if b == Succ(..) (impossible case)
  | .succ _ => reduceMax a b
  | .param _ idx => match a with
    | .param _ idx' => if idx == idx' then a else .imax a b
    | _ => .imax a b
  -- Otherwise, IMax(a, b) is stuck, with a and b reduced
  | _ => .imax a b

/--
Reduce, or simplify, the universe levels to a normal form. Notice that universe
levels with no free paramiables always reduce to a number, i.e., a sequence of
`succ`s followed by a `zero`
-/
def reduce : Level → Level
  | .succ u' => .succ (reduce u')
  | .max a b => reduceMax (reduce a) (reduce b)
  | .imax a b =>
    let b' := reduce b
    match b' with
    | .zero => .zero
    | .succ _ => reduceMax (reduce a) b'
    | _ => .imax (reduce a) b'
  | u => u

/--
Instantiate a paramiable and reduce at the same time. Assumes an already reduced
`subst`. This function is only used in the comparison algorithm, and it doesn't
shift paramiables, because we want to instantiate a paramiable `param idx` with
`succ (param idx)`, so by shifting the paramiables we would transform `param (idx+1)`
into `param idx` which is not what we want
-/
def instReduce (u : Level) (idx : Nat) (subst : Level) : Level :=
  match u with
  | .succ u => .succ (instReduce u idx subst)
  | .max a b => reduceMax (instReduce a idx subst) (instReduce b idx subst)
  | .imax a b =>
    let a' := instReduce a idx subst
    let b' := instReduce b idx subst
    match b' with
    | .zero => .zero
    | .succ _ => reduceMax a' b'
    | _ => .imax a' b'
  | .param _ idx' => if idx' == idx then subst else u
  | .zero => u

/--
Instantiate multiple paramiables at the same time and reduce. Assumes already
reduced `substs`
-/
def instBulkReduce (substs : List Level) : Level → Level
  | z@(.zero ..) => z
  | .succ u => .succ (instBulkReduce substs u)
  | .max a b => reduceMax (instBulkReduce substs a) (instBulkReduce substs b)
  | .imax a b =>
    let b' := instBulkReduce substs b
    match b' with
    | .zero => .zero
    | .succ _ => reduceMax (instBulkReduce substs a) b'
    | _ => .imax (instBulkReduce substs a) b'
  | .param n idx => match substs[idx]? with
    | some u => u
    -- This case should never happen if we're correctly enclosing every
    -- expression with a big enough universe environment
    | none => .param n (idx - substs.length)

/--
We say that two universe levels `a` and `b` are (semantically) equal, if they
are equal as numbers for all possible substitution of free paramiables to numbers.
Although writing an algorithm that follows this exact scheme is impossible, it
is possible to write one that is equivalent to such semantical equality.
Comparison algorithm `a <= b + diff`. Assumes `a` and `b` are already reduced
-/
partial def leq (a b : Level) (diff : Int) : Bool :=
  if diff >= 0 && a == .zero then true
  else match a, b with
  | .zero, .zero => diff >= 0
  --! Succ cases
  | .succ a, _ => leq a b (diff - 1)
  | _, .succ b => leq a b (diff + 1)
  | .param .., .zero => false
  | .zero, .param .. => diff >= 0
  | .param _ x, .param _ y => x == y && diff >= 0
  --! IMax cases
  -- The case `a = imax c d` has only three possibilities:
  -- 1) d = param ..
  -- 2) d = max ..
  -- 3) d = imax ..
  -- It can't be any otherway since we are assuming `a` is reduced, and thus `d` is reduced as well
  | .imax _ (.param n idx), _ =>
    -- In the case for `param idx`, we need to compare two substitutions:
    -- 1) idx <- zero
    -- 2) idx <- succ (param idx)
    -- In the first substitution, we know `a` becomes `zero`
    leq .zero (instReduce b idx .zero) diff &&
    let succ := .succ (.param n idx)
    leq (instReduce a idx succ) (instReduce b idx succ) diff

  | .imax c (.max e f), _ =>
    -- Here we use the relationship
    -- imax c (max e f) = max (imax c e) (imax c f)
    let new_max := reduceMax (reduceIMax c e) (reduceIMax c f)
    leq new_max b diff
  | .imax c (.imax e f), _ =>
    -- Here we use the relationship
    -- imax c (imax e f) = max (imax c e) (imax e f)
    let new_max := reduceMax (reduceIMax c e) (.imax e f)
    leq new_max b diff
  -- Analogous to previous case
  | _, .imax _ (.param n idx) =>
    leq (instReduce a idx .zero) .zero diff &&
    let succ := .succ (.param n idx)
    leq (instReduce a idx succ) (instReduce b idx succ) diff
  | _, .imax c (.max e f) =>
    let new_max := reduceMax (reduceIMax c e) (reduceIMax c f)
    leq a new_max diff
  | _, .imax c (.imax e f) =>
    let new_max := reduceMax (reduceIMax c e) (.imax e f)
    leq a new_max diff
  --! Max cases
  | .max c d, _ => leq c b diff && leq d b diff
  | _, .max c d => leq a c diff || leq a d diff
  | _, _ => false -- Impossible cases

/-- The equality algorithm. Assumes `a` and `b` are already reduced -/
def equalLevel (a b : Level) : Bool :=
  leq a b 0 && leq b a 0

/--
Two lists of universes are considered equal iff they have the same length and
`Ix.equalLevel` returns `true` for all of their zip pairs
-/
def equalLevels : List Level → List Level → Bool
  | [], [] => true
  | u::us, u'::us' => equalLevel u u' && equalLevels us us'
  | _, _ => false

/-- Faster equality for zero, assumes that the input is already reduced -/
def isZero : Level → Bool
  | .zero => true
  -- all other cases are false since they are either `succ` or a reduced
  -- expression with free paramiables, which are never semantically equal to zero
  | _ => false

end Ix.Level
