--import Blake3

--import Ix.Address
--import Ix.Ixon
--import Ix.Ixon.Serialize
--import Ix.Meta
--import Ix.CanonM
--import Batteries.Data.RBMap
--import Lean
--import Ix.Prove

--open Batteries (RBMap)

--namespace Ix
--
--inductive IxError
--| todo
--
--instance : ToString IxError where
--  toString p := s!"todo"
--
----instance : ToString Proof where
----  toString p := s!"<#{p.inp} ~> #{p.out} : #{p.typ}>"
--
--structure IxMEnv where
--  names : RBMap Lean.Name (Address × Address) compare
--  consts: RBMap Address Ixon.Const compare
--  secret: Address
--
--structure IxMState where
--  comms : RBMap Address Ixon.Comm compare
--  -- transcript : List IxVMOp
--  main : Option (Address × Ixon.Const)
--  deriving Inhabited
--
--abbrev IxM := ReaderT IxMEnv $ ExceptT IxError $ StateT IxMState Id
--
--def IxM.run (env: Lean.Environment) (secret: Lean.Name) (ixm: IxM Claim)
--  : IO (Claim × IxMState × IxMEnv) := do
--  let stt <- IO.ofExcept (<- Ix.CanonM.canonicalizeEnv env)
--  let (secret, _) := stt.names.find! secret
--  let env := IxMEnv.mk stt.names stt.store secret
--  let (res, stt) := Id.run (StateT.run (ReaderT.run ixm env) default)
--  let claim <- IO.ofExcept res
--  return (claim, stt, env)
--
--def IxM.commit (payload: Address): IxM Address := do
--  let secret <- (·.secret) <$> read
--  let comm := Ixon.Comm.mk secret payload
--  let addr := Address.blake3 (Ixon.Serialize.put (Ixon.Const.comm comm))
--  modify (fun stt => { stt with
--    comms := stt.comms.insert addr comm
--    -- transcript := (.commit payload secret addr)::stt.transcript
--  })
--  return addr
--
--def IxM.byName (name: Lean.Name) : IxM Address := do
--  let env <- read
--  match env.names.find? name with
--  | .none => throw .todo
--  | .some (addr, _) => return addr
--
--def IxM.reveal (comm: Address) : IxM Address := do
--  let stt <- get
--  match stt.comms.find? comm with
--  | .some c => return c.payload
--  | .none => throw .todo
--
--def IxM.secret (comm: Address) : IxM Address := do
--  let stt <- get
--  match stt.comms.find? comm with
--  | .some c => return c.secret
--  | .none => throw .todo
--
---- TODO: handle universe arguments
--def IxM.mkMainConst (type func: Address) (args: List Address): Ixon.Const :=
--  match args with
--  | [] =>
--    Ixon.Const.defn {
--      lvls := 0,
--      type := Ixon.Expr.cnst type [],
--      value := Ixon.Expr.cnst func [],
--      part := .true,
--    }
--  | a::as =>
--    let as':= as.map (fun a => Ixon.Expr.cnst a [])
--    Ixon.Const.defn {
--      lvls := 0,
--      type := Ixon.Expr.cnst type [],
--      value := Ixon.Expr.apps (Ixon.Expr.cnst func []) (Ixon.Expr.cnst a []) as' ,
--      part := .true,
--    }
--
--def IxM.mkMain (type func: Address) (args: List Address): IxM Address := do
--  let mainConst := IxM.mkMainConst type func args
--  let bytes := Ixon.Serialize.put mainConst
--  let addr := Address.blake3 bytes
--  modify (fun stt => { stt with main := .some (addr, mainConst) })
--  return addr
--
--def IxM.evaluate (type input: Address) : IxM Address := sorry
--
--def IxM.prove (claim : Claim) (stt: IxMState) (env: IxMEnv) : IO Proof :=
--  sorry
--
--end Ix
--
